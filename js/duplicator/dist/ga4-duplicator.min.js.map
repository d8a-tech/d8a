{
  "version": 3,
  "sources": ["../src/ga4-duplicator.ts"],
  "sourcesContent": ["/**\n * GA4 Duplicator - Intercepts GA4 collect calls and sends duplicates to D8A.\n */\n\ninterface GA4Destination {\n  measurement_id: string;\n  server_container_url: string;\n  server_container_path?: string;\n}\n\ninterface GA4DuplicatorOptions {\n  server_container_url?: string;\n  server_container_path?: string;\n  destinations?: GA4Destination[];\n  debug?: boolean;\n}\n\n(window as any).createGA4Duplicator = function (options: GA4DuplicatorOptions) {\n  /**\n   * Shared logic and configuration for interceptors.\n   */\n  interface InterceptorContext {\n    debug: boolean;\n    isTargetUrl(url: string | null | undefined): boolean;\n    buildDuplicateUrl(url: string): string;\n  }\n\n  /**\n   * Base interface for monkey-patching implementations.\n   */\n  interface NetworkInterceptor {\n    install(context: InterceptorContext): void;\n  }\n\n  class FetchInterceptor implements NetworkInterceptor {\n    install(ctx: InterceptorContext): void {\n      const originalFetch = window.fetch;\n      window.fetch = function (\n        this: any,\n        resource: RequestInfo | URL,\n        config?: RequestInit,\n      ): Promise<Response> {\n        const requestUrl =\n          typeof resource === \"string\"\n            ? resource\n            : resource instanceof URL\n              ? resource.toString()\n              : (resource as any).url;\n        const method = (config && config.method) || (resource as any).method || \"GET\";\n\n        if (ctx.isTargetUrl(requestUrl)) {\n          const upperMethod = (method || \"GET\").toUpperCase();\n\n          // If we need the body from a Request, clone BEFORE calling the original fetch\n          let prepareBodyPromise: Promise<any> = Promise.resolve(undefined);\n          if (upperMethod === \"POST\") {\n            if (config && Object.prototype.hasOwnProperty.call(config, \"body\")) {\n              prepareBodyPromise = Promise.resolve(config.body);\n            } else if (typeof Request !== \"undefined\" && resource instanceof Request) {\n              try {\n                const clonedReq = resource.clone();\n                prepareBodyPromise = clonedReq.blob().catch(() => undefined);\n              } catch {\n                prepareBodyPromise = Promise.resolve(undefined);\n              }\n            }\n          }\n\n          // First send original request to Google Analytics\n          const originalPromise = originalFetch.apply(this, arguments as any);\n\n          // Then send duplicate\n          const duplicateUrl = ctx.buildDuplicateUrl(requestUrl);\n\n          if (upperMethod === \"GET\") {\n            originalFetch(duplicateUrl, { method: \"GET\", keepalive: true }).catch((error) => {\n              if (ctx.debug) console.error(\"gtm interceptor: error duplicating GET fetch:\", error);\n            });\n          } else if (upperMethod === \"POST\") {\n            prepareBodyPromise.then((dupBody) => {\n              originalFetch(duplicateUrl, { method: \"POST\", body: dupBody, keepalive: true }).catch(\n                (error) => {\n                  if (ctx.debug)\n                    console.error(\"gtm interceptor: error duplicating POST fetch:\", error);\n                },\n              );\n            });\n          }\n\n          return originalPromise;\n        }\n\n        return originalFetch.apply(this, arguments as any);\n      };\n    }\n  }\n\n  class XhrInterceptor implements NetworkInterceptor {\n    install(ctx: InterceptorContext): void {\n      const originalXHROpen = XMLHttpRequest.prototype.open;\n      const originalXHRSend = XMLHttpRequest.prototype.send;\n\n      XMLHttpRequest.prototype.open = function (this: any, method: string, url: string | URL) {\n        this._requestMethod = method;\n        this._requestUrl = url;\n        return originalXHROpen.apply(this, arguments as any);\n      };\n\n      XMLHttpRequest.prototype.send = function (\n        this: any,\n        body?: Document | XMLHttpRequestBodyInit | null,\n      ) {\n        if (this._requestUrl && ctx.isTargetUrl(this._requestUrl)) {\n          // First send original request to Google Analytics\n          const originalResult = originalXHRSend.apply(this, arguments as any);\n\n          // Then send duplicate to our endpoint mimicking method and payload\n          try {\n            const method = (this._requestMethod || \"GET\").toUpperCase();\n            const duplicateUrl = ctx.buildDuplicateUrl(this._requestUrl);\n\n            if (method === \"GET\") {\n              fetch(duplicateUrl, { method: \"GET\", keepalive: true }).catch((error) => {\n                if (ctx.debug) console.error(\"gtm interceptor: error duplicating GET xhr:\", error);\n              });\n            } else if (method === \"POST\") {\n              fetch(duplicateUrl, { method: \"POST\", body: body as any, keepalive: true }).catch(\n                (error) => {\n                  if (ctx.debug)\n                    console.error(\"gtm interceptor: error duplicating POST xhr:\", error);\n                },\n              );\n            }\n          } catch (dupErr) {\n            if (ctx.debug) console.error(\"gtm interceptor: xhr duplication failed:\", dupErr);\n          }\n          return originalResult;\n        }\n        return originalXHRSend.apply(this, arguments as any);\n      };\n    }\n  }\n\n  class BeaconInterceptor implements NetworkInterceptor {\n    install(ctx: InterceptorContext): void {\n      if (!navigator.sendBeacon) return;\n\n      const originalSendBeacon = navigator.sendBeacon;\n      navigator.sendBeacon = function (\n        this: any,\n        url: string | URL,\n        data?: BodyInit | null,\n      ): boolean {\n        if (ctx.isTargetUrl(url as string)) {\n          const originalResult = originalSendBeacon.apply(this, arguments as any);\n          try {\n            originalSendBeacon.call(navigator, ctx.buildDuplicateUrl(url as string), data);\n          } catch (e) {\n            if (ctx.debug) console.error(\"gtm interceptor: error duplicating sendBeacon:\", e);\n          }\n          return originalResult;\n        }\n        return originalSendBeacon.apply(this, arguments as any);\n      };\n    }\n  }\n\n  class ScriptInterceptor implements NetworkInterceptor {\n    install(ctx: InterceptorContext): void {\n      try {\n        const scriptSrcDescriptor = Object.getOwnPropertyDescriptor(\n          HTMLScriptElement.prototype,\n          \"src\",\n        );\n        const originalScriptSrcSetter = scriptSrcDescriptor && scriptSrcDescriptor.set;\n        const originalScriptSrcGetter = scriptSrcDescriptor && scriptSrcDescriptor.get;\n        const originalScriptSetAttribute = HTMLScriptElement.prototype.setAttribute;\n\n        const duplicateIfGA4Url = (urlString: string) => {\n          try {\n            if (!ctx.isTargetUrl(urlString)) return;\n            fetch(ctx.buildDuplicateUrl(urlString), { method: \"GET\", keepalive: true }).catch(\n              (error) => {\n                if (ctx.debug)\n                  console.error(\"gtm interceptor: error duplicating script GET:\", error);\n              },\n            );\n          } catch {\n            // Intentionally empty\n          }\n        };\n\n        if (originalScriptSrcSetter && originalScriptSrcGetter) {\n          const setter = originalScriptSrcSetter;\n          const getter = originalScriptSrcGetter;\n          Object.defineProperty(HTMLScriptElement.prototype, \"src\", {\n            configurable: true,\n            enumerable: true,\n            get: function (this: any) {\n              return getter.call(this);\n            },\n            set: function (this: any, value: string) {\n              try {\n                const last = this.__ga4LastSrcDuplicated;\n                if (value && value !== last) {\n                  duplicateIfGA4Url(String(value));\n                  this.__ga4LastSrcDuplicated = String(value);\n                }\n                const self = this;\n                const onloadOnce = function () {\n                  try {\n                    const finalUrl = self.src;\n                    if (finalUrl && finalUrl !== self.__ga4LastSrcDuplicated) {\n                      duplicateIfGA4Url(finalUrl);\n                      self.__ga4LastSrcDuplicated = finalUrl;\n                    }\n                  } catch {}\n                  self.removeEventListener(\"load\", onloadOnce);\n                };\n                this.addEventListener(\"load\", onloadOnce);\n              } catch {}\n              setter.call(this, value);\n            },\n          });\n        }\n\n        HTMLScriptElement.prototype.setAttribute = function (\n          this: any,\n          name: string,\n          value: string,\n        ) {\n          try {\n            if (String(name).toLowerCase() === \"src\") {\n              const v = String(value);\n              const last = this.__ga4LastSrcDuplicated;\n              if (v && v !== last) {\n                duplicateIfGA4Url(v);\n                this.__ga4LastSrcDuplicated = v;\n              }\n              const selfAttr = this;\n              const onloadOnceAttr = function () {\n                try {\n                  const finalUrlAttr = selfAttr.src;\n                  if (finalUrlAttr && finalUrlAttr !== selfAttr.__ga4LastSrcDuplicated) {\n                    duplicateIfGA4Url(finalUrlAttr);\n                    selfAttr.__ga4LastSrcDuplicated = finalUrlAttr;\n                  }\n                } catch {}\n                selfAttr.removeEventListener(\"load\", onloadOnceAttr);\n              };\n              this.addEventListener(\"load\", onloadOnceAttr);\n            }\n          } catch {\n            // Intentionally empty\n          }\n          return originalScriptSetAttribute.apply(this, arguments as any);\n        };\n      } catch {}\n    }\n  }\n\n  if ((window as any).__ga4DuplicatorInitialized) {\n    if (options.debug) console.warn(\"GA4 Duplicator: already initialized.\");\n    return;\n  }\n\n  const destinations: GA4Destination[] = [];\n  if (options.destinations && Array.isArray(options.destinations)) {\n    for (let i = 0; i < options.destinations.length; i++) {\n      destinations.push(options.destinations[i]);\n    }\n  }\n\n  if (options.server_container_url) {\n    destinations.push({\n      measurement_id: \"*\",\n      server_container_url: options.server_container_url,\n      server_container_path: options.server_container_path,\n    });\n  }\n\n  if (destinations.length === 0) {\n    console.error(\"GA4 Duplicator: either server_container_url or destinations array is required\");\n    return;\n  }\n\n  function normalizePath(p: string): string {\n    p = String(p || \"\");\n    p = p.replace(/\\/+$/, \"\");\n    return p === \"\" ? \"/\" : p;\n  }\n\n  function joinPaths(a: string, b: string) {\n    return a.replace(/\\/+$/, \"\") + \"/\" + b.replace(/^\\/+/, \"\");\n  }\n\n  function matchesId(pattern: string, id: string): boolean {\n    if (!pattern || pattern === \"*\") return true;\n    try {\n      const regexStr = pattern.replace(/[.+^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/\\*/g, \".*\");\n      return new RegExp(\"^\" + regexStr + \"$\", \"i\").test(id);\n    } catch {\n      return pattern.toLowerCase() === id.toLowerCase();\n    }\n  }\n\n  function getMeasurementId(url: string): string {\n    try {\n      const parsed = new URL(url, location.href);\n      return parsed.searchParams.get(\"tid\") || parsed.searchParams.get(\"id\") || \"\";\n    } catch {\n      const match = url.match(/[?&](?:tid|id)=([^&?#]+)/);\n      return match ? decodeURIComponent(match[1]) : \"\";\n    }\n  }\n\n  function getDestinationForId(id: string): GA4Destination | null {\n    for (let i = 0; i < destinations.length; i++) {\n      if (matchesId(destinations[i].measurement_id, id)) {\n        return destinations[i];\n      }\n    }\n    return null;\n  }\n\n  function getDuplicateEndpointUrl(dest: GA4Destination): URL {\n    const trackingURL = String(dest.server_container_url || \"\")\n      .trim()\n      .replace(/\\/+$/, \"\");\n    const serverContainerPath = dest.server_container_path || \"/g/collect\";\n\n    const u = new URL(trackingURL, location.href);\n    if (!u.pathname || u.pathname === \"/\") u.pathname = \"/g/collect\";\n\n    u.pathname = joinPaths(normalizePath(u.pathname), serverContainerPath);\n    u.search = \"\";\n    u.hash = \"\";\n    return u;\n  }\n\n  function isTargetUrl(url: string | null | undefined): boolean {\n    if (!url || typeof url !== \"string\") return false;\n    try {\n      const parsed = new URL(url, location.href);\n\n      for (let i = 0; i < destinations.length; i++) {\n        const duplicateTarget = getDuplicateEndpointUrl(destinations[i]);\n        if (\n          parsed.origin === duplicateTarget.origin &&\n          normalizePath(parsed.pathname) === normalizePath(duplicateTarget.pathname)\n        ) {\n          return false;\n        }\n      }\n\n      const params = parsed.searchParams;\n      const hasGtm = params.has(\"gtm\");\n      const hasTagExp = params.has(\"tag_exp\");\n      const measurementId = params.get(\"tid\") || params.get(\"id\") || \"\";\n      const isMeasurementIdGA4 = /^G-[A-Z0-9]+$/i.test(measurementId);\n\n      return hasGtm && hasTagExp && isMeasurementIdGA4;\n    } catch {\n      if (typeof url === \"string\") {\n        for (let j = 0; j < destinations.length; j++) {\n          try {\n            const target = getDuplicateEndpointUrl(destinations[j]);\n            const targetNoQuery = target.origin + target.pathname;\n            if (url.indexOf(targetNoQuery) !== -1) return false;\n          } catch {\n            // Intentionally empty\n          }\n        }\n\n        const hasGtmFallback = url.indexOf(\"gtm=\") !== -1;\n        const hasTagExpFallback = url.indexOf(\"tag_exp=\") !== -1;\n        const idMatch = url.match(/[?&](?:tid|id)=G-[A-Za-z0-9]+/);\n        return !!(hasGtmFallback && hasTagExpFallback && idMatch);\n      }\n      return false;\n    }\n  }\n\n  function buildDuplicateUrl(originalUrl: string): string {\n    const id = getMeasurementId(originalUrl);\n    const dest = getDestinationForId(id);\n    if (!dest) return \"\";\n\n    const dst = getDuplicateEndpointUrl(dest);\n    try {\n      const src = new URL(originalUrl, location.href);\n      dst.search = src.search;\n    } catch {}\n    return dst.toString();\n  }\n\n  const context: InterceptorContext = {\n    debug: !!options.debug,\n    isTargetUrl,\n    buildDuplicateUrl,\n  };\n\n  const interceptors: NetworkInterceptor[] = [\n    new FetchInterceptor(),\n    new XhrInterceptor(),\n    new BeaconInterceptor(),\n    new ScriptInterceptor(),\n  ];\n\n  for (let i = 0; i < interceptors.length; i++) {\n    try {\n      interceptors[i].install(context);\n    } catch (e) {\n      if (options.debug) console.error(\"GA4 Duplicator: failed to install interceptor\", e);\n    }\n  }\n\n  (window as any).__ga4DuplicatorInitialized = true;\n};\n"],
  "mappings": "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",
  "names": ["options", "FetchInterceptor", "ctx", "originalFetch", "resource", "config", "requestUrl", "method", "upperMethod", "prepareBodyPromise", "e", "originalPromise", "duplicateUrl", "error", "dupBody", "XhrInterceptor", "originalXHROpen", "originalXHRSend", "url", "body", "originalResult", "dupErr", "BeaconInterceptor", "originalSendBeacon", "data", "ScriptInterceptor", "scriptSrcDescriptor", "originalScriptSrcSetter", "originalScriptSrcGetter", "originalScriptSetAttribute", "duplicateIfGA4Url", "urlString", "setter", "getter", "value", "last", "self", "onloadOnce", "finalUrl", "name", "v", "selfAttr", "onloadOnceAttr", "finalUrlAttr", "destinations", "i", "normalizePath", "p", "joinPaths", "a", "b", "matchesId", "pattern", "id", "regexStr", "getMeasurementId", "parsed", "match", "getDestinationForId", "getDuplicateEndpointUrl", "dest", "trackingURL", "serverContainerPath", "u", "isTargetUrl", "duplicateTarget", "params", "hasGtm", "hasTagExp", "measurementId", "isMeasurementIdGA4", "j", "target", "targetNoQuery", "hasGtmFallback", "hasTagExpFallback", "idMatch", "buildDuplicateUrl", "originalUrl", "dst", "src", "context", "interceptors"]
}
